const { proto } = require('@adiwajshing/baileys-md')const chalk = require('chalk')const fs = require('fs')const Crypto = require('crypto')const axios = require('axios')const moment = require('moment-timezone')const { sizeFormatter } = require('human-readable')const util = require('util')const jimp = require('jimp')const { defaultMaxListeners } = require('stream') const unixTimestampSeconds = (date = new Date()) => Math.floor(date.getTime() / 1000) exports.unixTimestampSeconds = unixTimestampSeconds exports.generateMessageTag = (epoch) => { let tag = (0, exports.unixTimestampSeconds)().toString(); if (epoch) tag += '.--' + epoch; // attach epoch if provided return tag;} exports.processTime = (timestamp, now) => {	return moment.duration(now - moment(timestamp * 1000)).asSeconds()} exports.getRandom = (ext) => { return `${Math.floor(Math.random() * 10000)}${ext}`} exports.getBuffer = async (url, options) => {	try {		options ? options : {}		const res = await axios({			method: "get",			url,			headers: {				'DNT': 1,				'Upgrade-Insecure-Request': 1			},			...options,			responseType: 'arraybuffer'		})		return res.data	} catch (e) {		return err	}} exports.fetchJson = async (url, options) => { try { options ? options : {} const res = await axios({ method: 'GET', url: url, headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36' }, ...options }) return res.data } catch (err) { return err }} exports.runtime = function(seconds) {	seconds = Number(seconds);	var d = Math.floor(seconds / (3600 * 24));	var h = Math.floor(seconds % (3600 * 24) / 3600);	var m = Math.floor(seconds % 3600 / 60);	var s = Math.floor(seconds % 60);	var dDisplay = d > 0 ? d + (d == 1 ? " day, " : " days, ") : "";	var hDisplay = h > 0 ? h + (h == 1 ? " hour, " : " hours, ") : "";	var mDisplay = m > 0 ? m + (m == 1 ? " minute, " : " minutes, ") : "";	var sDisplay = s > 0 ? s + (s == 1 ? " second" : " seconds") : "";	return dDisplay + hDisplay + mDisplay + sDisplay;} exports.clockString = function(seconds) { let h = isNaN(seconds) ? '--' : Math.floor(seconds % (3600 * 24) / 3600) let m = isNaN(seconds) ? '--' : Math.floor(seconds % 3600 / 60) let s = isNaN(seconds) ? '--' : Math.floor(seconds % 60) return [h, m, s].map(v => v.toString().padStart(2, 0)).join(':')
